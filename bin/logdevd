#!/usr/bin/python

import sys
import optparse
import logdevd
import signal
import json

#-----------------------------------------------------------------------------
# command line options {{{

parser = optparse.OptionParser(
    usage = "%prog [options]"
)

parser.add_option(
    "-c", "--config", dest = "config",
    default = "/etc/logdevourer/logdevourer.conf",
    help = "configuration file", metavar = "FILE",
)
parser.add_option(
    "-s", "--state-dir", dest = "state_dir",
    default = "/var/lib/logdevourer",
    help = "PID file for going daemon", metavar = "FILE",
)
parser.add_option(
    "-p", "--pid-file", dest = "pid_file", default = None,
    help = "PID file for going daemon", metavar = "FILE",
)
parser.add_option(
    "-d", "--daemon", dest = "daemonize",
    action = "store_true", default = False,
    help = "detach from terminal (run as a daemon)",
)
parser.add_option(
    "-u", "--user", dest = "user", default = None,
    help = "user to run as",
)
parser.add_option(
    "-g", "--group", dest = "group", default = None,
    help = "group to run as",
)

(options, args) = parser.parse_args()

# }}}
#-----------------------------------------------------------------------------
# main loop, along with state variables and options {{{

class Daemon:
    def __init__(self, config, state_dir):
        self.config = config
        self.log_unparsed = False
        self.send_unparsed = True
        self.state_dir = state_dir
        self.poll_h = None
        self.sources = []
        self.destinations = []
        self.lognorm = None
        # TODO: raise exception on error (no previous config to fall back to)
        self.reload()

    def reload(self):
        # before replacing sources, inform those that they might want to flush
        # their (buffered) state to disk
        for source in self.sources:
            source.flush()
        # TODO: try-catch
        cfg = logdevd.config.load(self.config, self.state_dir)
        # TODO: convergence
        (self.sources, self.destinations, self.lognorm, config) = cfg
        self.poll_h = logdevd.poll.Poll()
        self.reopen_sources_if_necessary()
        self.send_unparsed = config["options"].get("send_unparsed", True)
        self.log_unparsed  = config["options"].get("log_unparsed", False)

    def reopen_sources_if_necessary(self):
        for source in self.sources:
            if source not in self.poll_h:
                # add missing files
                source.open()
                self.poll_h.add(source)
            elif source.reopen_necessary():
                # reopen files that need it
                self.poll_h.remove(source)
                source.reopen()
                self.poll_h.add(source)

    def normalize(self, log_line):
        result = self.lognorm.normalize(log_line)
        # XXX: "*" field is expected to be JSON string, since liblognorm 1.1.1
        # doesn't have "json" field type yet
        if "*" in result:
            try:
                result.update(json.loads(result.pop("*")))
            except:
                return None
        # remains after parsing the log line
        if "originalmsg" in result and "unparsed-data" in result:
            if not self.send_unparsed:
                return None
        return result

    def fan_out(self, message):
        line = json.dumps(message, sort_keys = True)
        for d in self.destinations:
            d.send(line)

    def poll(self, timeout):
        return self.poll_h.poll(timeout)

    def sighandler(self, signum, stack_frame):
        if signum == signal.SIGHUP:
            self.reload()
        elif signum == signal.SIGTERM or signum == signal.SIGINT:
            sys.exit()
        # else ignore

# }}}
#-----------------------------------------------------------------------------

daemon = Daemon(options.config, options.state_dir)

signal.signal(signal.SIGHUP, daemon.sighandler)
signal.signal(signal.SIGINT, daemon.sighandler)
signal.signal(signal.SIGTERM, daemon.sighandler)

#-----------------------------------------------------------------------------
# daemonization {{{

pid_file = logdevd.daemonize.PidFile(options.pid_file) # None is OK

logdevd.daemonize.setguid(options.user, options.group)

if options.daemonize:
    result = logdevd.daemonize.detach("/")
    if result == logdevd.daemonize.PARENT:
        sys.exit(0)
    # else: result == logdevd.daemonize.CHILD
    # errors result in an exception
    pid_file.update()

# set remove-on-close flag
pid_file.claim()

# }}}
#-----------------------------------------------------------------------------

while True:
    # check every 250ms for sources that need reopening
    canread = daemon.poll(250)
    for source in canread:
        for line in source.try_readlines():
            message = daemon.normalize(line)
            if message is not None:
                daemon.fan_out(message)
    daemon.reopen_sources_if_necessary()

#-----------------------------------------------------------------------------
# vim:ft=python:foldmethod=marker
